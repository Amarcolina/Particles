#pragma kernel Simulate
#pragma kernel Integrate_Naive
#pragma kernel Integrate_X
#pragma kernel Integrate_Y
#pragma kernel Integrate_Z
#pragma kernel Copy
#pragma kernel Sort

#define BOX_SIDE 64
#define BOX_COUNT (BOX_SIDE * BOX_SIDE * BOX_SIDE)

uniform float3 _Center;

struct Particle {
  float3 position;
  float3 velocity;
  float3 color;
};

RWStructuredBuffer<Particle> _ParticleFront;
RWStructuredBuffer<Particle> _ParticleBack;

RWStructuredBuffer<uint> _Count;

RWStructuredBuffer<uint> _BoxStart;
RWStructuredBuffer<uint> _BoxCount;

float noise(float2 n ){
	return frac(sin(dot(n.xy, float2(12.9898, 78.233)))* 43758.5453);
}

uint3 GetBoxPos(float3 position) {
 return (uint3)(position * 12 + float3(BOX_SIDE, BOX_SIDE, BOX_SIDE) * 0.5);
}

uint GetBox(uint3 boxPos){
  return boxPos.x + boxPos.y * BOX_SIDE + boxPos.z * BOX_SIDE * BOX_SIDE;
}

uint GetBox(float3 position){
  return GetBox(GetBoxPos(position));
}

float3 rgb2hsv(float3 c)
{
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
 
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float3 hsv2rgb(float3 c)
{
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

[numthreads(64,1,1)]
void Simulate(uint3 id : SV_DispatchThreadID) {
  uint index = id.x;

  //Grab the particle from the front buffer
  Particle particle = _ParticleFront[index];

  /*
  if(length(particle.position) < 0.02) {
    particle.position = particle.position +  float3(2, 0, 0);
    particle.velocity = float3(0,0,0);
  }
  */

  uint total = 0;
  uint3 boxPos = GetBoxPos(particle.position);
  for(int dx=-1;dx<=1; dx++) {
    for(int dy=-1; dy<=1; dy++) {
      for(int dz=-1; dz<=1; dz++) {
        uint3 deltaBoxPos = boxPos + uint3(dx, dy, dz);
        uint deltaBox = GetBox(deltaBoxPos);

        uint start = _BoxStart[deltaBox];
        uint count = _BoxCount[deltaBox];

        for(uint i=start; i<start + count; i++){
          if(i == index) continue;

          Particle other = _ParticleFront[i];
          float3 fromOther = (particle.position - other.position);
          float distSqrd = dot(fromOther, fromOther);
          if(distSqrd < 0.035 * 0.035) {
            float dist = sqrt(distSqrd);

            total++;
            particle.color += 0.01 * other.color;
            particle.velocity += fromOther / dist * (0.035 - dist) * 0.1;
          }
        }
      }
    }
  }

  particle.color = normalize(particle.color);
  
  float3 hsv = rgb2hsv(particle.color);
  hsv.y = clamp(hsv.y, 0.2, 1);
  hsv.x = clamp(hsv.x, 0, 1);
  hsv.z = clamp(hsv.z, 0, 1);
  particle.color = hsv2rgb(hsv);




  float maxC = max(particle.color.r, max(particle.color.g, particle.color.b));
  if(particle.color.r >= maxC) {
    particle.color.r += 0.01;
  }
    if(particle.color.g >= maxC) {
    particle.color.g += 0.01;
  }
    if(particle.color.b >= maxC) {
    particle.color.b += 0.01;
  }

  float3 toCenter = (_Center - particle.position);
  float3 forceToCenter = normalize(toCenter) / (1 + dot(toCenter, toCenter));

  float3 aroundCenter = cross(_Center - particle.position, float3(0,1,0));
  float3 forceAroundCenter = normalize(aroundCenter) / (0.3 + dot(toCenter, toCenter));

  particle.velocity += forceToCenter * 0.0002;
  particle.velocity += forceAroundCenter * 0.0001;

  particle.velocity *= 0.99;

  //Do simulation here
  particle.position += particle.velocity;

  //Increment the count of the new box we have landed in
  uint newBox = GetBox(particle.position);
  InterlockedAdd(_Count[newBox], 1);

  //Set color based on box

  float r = noise(float2(newBox, newBox * 23));
  float g = noise(float2(newBox * 44, newBox + 99));
  float b = noise(float2(newBox * 3.4, newBox * 9));

  //particle.color += 0.01 * float3(r, g, b);
  //particle.color += float3(saturate(length(10 * particle.velocity) - 1), 0, 0);

  //Store the particle into the back buffer
  _ParticleBack[index] = particle;
}

[numthreads(64,1,1)]
void Integrate_Naive (uint3 id : SV_DispatchThreadID)
{
  uint index = id.x;
  uint sum = 0;
  for(uint i=0; i<=index; i++){
    sum += _Count[i];
  }

  _BoxStart[index] = sum;
  _BoxCount[index] = _Count[index];
  _Count[index] = 0;
}

[numthreads(4,4,4)]
void Integrate_X (uint3 id : SV_DispatchThreadID)
{
  uint start = id.y * BOX_SIDE + id.z * BOX_SIDE * BOX_SIDE;
  uint index = start + id.x;

  uint sum = 0;
  for(uint i=start; i<=index; i++){
    sum += _Count[i];
  }

  _BoxStart[index] = sum;
}

[numthreads(4,4,4)]
void Integrate_Y (uint3 id : SV_DispatchThreadID)
{
  uint index = id.x + id.y * BOX_SIDE + id.z * BOX_SIDE * BOX_SIDE;
  uint start = (BOX_SIDE - 1) + id.z * BOX_SIDE * BOX_SIDE;

  uint sum = _BoxStart[index];
  for(uint i=start; i<index; i += BOX_SIDE){
    sum += _BoxStart[i];
  }

  _BoxCount[index] = sum;
}

[numthreads(4,4,4)]
void Integrate_Z (uint3 id : SV_DispatchThreadID)
{
  uint index = id.x + id.y * BOX_SIDE + id.z * BOX_SIDE * BOX_SIDE;
  uint start = (BOX_SIDE - 1) + ((BOX_SIDE - 1) * BOX_SIDE);

  uint sum = _BoxCount[index];
  for(uint i=start; i<index; i += (BOX_SIDE * BOX_SIDE)){
    sum += _BoxCount[i];
  }

  _BoxStart[index] = sum;
}

[numthreads(64,1,1)]
void Copy(uint3 id : SV_DispatchThreadID) {
  uint index = id.x;

  _BoxCount[index] = _Count[index];
  _Count[index] = 0;
}

[numthreads(64,1,1)]
void Sort(uint3 id : SV_DispatchThreadID) {
  uint index = id.x;

  Particle particle = _ParticleBack[index];

  uint box = GetBox(particle.position);

  uint newIndex;
  InterlockedAdd(_BoxStart[box], -1, newIndex);
  newIndex--;

  _ParticleFront[newIndex] = particle;
}
