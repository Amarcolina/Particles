#pragma kernel Integrate
#pragma kernel ResolveCollisions
#pragma kernel Accumulate_X
#pragma kernel Accumulate_Y
#pragma kernel Accumulate_Z
#pragma kernel Copy
#pragma kernel Sort

#define RADIUS 0.0175
#define SQR_RADIUS (RADIUS * RADIUS)

#define BOX_SIDE 64
#define BOX_SIZE (1.0 / 28.0)
#define BOX_COUNT (BOX_SIDE * BOX_SIDE * BOX_SIDE)

uniform float3 _Center;

struct Particle {
  float3 position;
  float3 prevPosition;
  float3 color;
};

struct Capsule {
  float3 a;
  float3 b;
};

struct DebugData {
  uint tests;
};

#define CAPSULE_RADIUS 0.025
uniform int _CapsuleCount;
StructuredBuffer<Capsule> _Capsules;

RWStructuredBuffer<Particle> _ParticleFront;
RWStructuredBuffer<Particle> _ParticleBack;

RWStructuredBuffer<uint> _Count;

RWStructuredBuffer<uint> _BoxStart;
RWStructuredBuffer<uint> _BoxEnd;

RWStructuredBuffer<DebugData> _DebugData;

float noise(float2 n) {
  return frac(sin(dot(n.xy, float2(12.9898, 78.233)))* 43758.5453);
}

uint3 GetBoxPos(float3 position) {
  return (uint3)(position / BOX_SIZE + float3(BOX_SIDE, BOX_SIDE, BOX_SIDE) * 0.5);
}

uint GetBox(uint3 boxPos) {
  return boxPos.x + boxPos.y * BOX_SIDE + boxPos.z * BOX_SIDE * BOX_SIDE;
}

uint GetBox(float3 position) {
  return GetBox(GetBoxPos(position));
}

float3 rgb2hsv(float3 c)
{
  float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
  float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
  float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10;
  return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float3 hsv2rgb(float3 c)
{
  float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

[numthreads(64, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID) {
  uint index = id.x;

  Particle particle = _ParticleFront[index];

  float3 toCenter = (_Center - particle.position);
  float3 forceToCenter = normalize(toCenter) / (1 + dot(toCenter, toCenter));

  float3 aroundCenter = cross(_Center - particle.position, float3(0, 1, 0));
  float3 forceAroundCenter = normalize(aroundCenter) / (0.1 + dot(toCenter, toCenter));

  {
    float3 tempPos = particle.position;

    particle.position += 0.9999 * (particle.position - particle.prevPosition);
    particle.position += forceToCenter * 0.0002;
    //particle.position += forceAroundCenter * 0.00001;
    particle.position.y -= 0.0001;

    particle.prevPosition = tempPos;
  }

  _ParticleFront[index] = particle;
}

void runParticleCollision(uint index, Particle particle, Particle other, inout float4 depenetration) {
  float3 fromOther = (particle.position - other.position);
  float distSqrd = dot(fromOther, fromOther);

  if (distSqrd < SQR_RADIUS) {
    /*
    float deltaLength = length(fromOther);
    float diff = (deltaLength - RADIUS) / deltaLength;
    depenetration -= fromOther * diff * 0.5;
    */

    fromOther *= SQR_RADIUS / (distSqrd + SQR_RADIUS) - 0.5;
    depenetration += float4(fromOther, 1);
  }
}

void resolveParticleCollisions3x3(uint index, inout Particle particle) {
  uint3 boxPos = GetBoxPos(particle.position);

  float4 depenetration = float4(0, 0, 0, 0);
  uint collisions = 0;
  for (int dx = -1; dx <= 1; dx++) {
    for (int dy = -1; dy <= 1; dy++) {
      for (int dz = -1; dz <= 1; dz++) {
        uint3 deltaBoxPos = boxPos + uint3(dx, dy, dz);
        uint deltaBox = GetBox(deltaBoxPos);

        uint start = _BoxStart[deltaBox];
        uint end = _BoxEnd[deltaBox];

        for (uint i = start; i < end; i++) {
          if (i == index) continue;

          Particle other = _ParticleFront[i];
          runParticleCollision(index, particle, other, depenetration);
        }
      }
    }
  }

  if (depenetration.w > 0) {
    particle.position += depenetration.xyz / depenetration.w;
  }
}

void doParticleForeach(uint index, uint start, uint end, Particle particle, inout float4 depenetration) {
  for (uint i = start; i < end; ++i) {
    Particle other = _ParticleFront[i];
    runParticleCollision(index, particle, other, depenetration);
  }
}

void resolveParticleCollisions2x2(uint index, inout Particle particle) {
  float3 boxFloatPos = particle.position / BOX_SIZE + float3(BOX_SIDE, BOX_SIDE, BOX_SIDE) * 0.5;
  uint3 boxPos = (uint3)boxFloatPos;

  int3 offset;
  offset.x = 0;
  offset.y = frac(boxFloatPos.y) > 0.5 ? 1 : -1;
  offset.z = frac(boxFloatPos.z) > 0.5 ? 1 : -1;

  boxPos.x += (frac(boxFloatPos.x) < 0.5) ? -1 : 0;

  float4 depenetration = float4(0, 0, 0, 0);

  int boxA = GetBox(boxPos + int3(0, offset.y, 0));
  int boxA_Start = _BoxStart[boxA];
  int boxA_End = _BoxEnd[boxA + 1];

  doParticleForeach(index, boxA_Start, boxA_End, particle, depenetration);

  int boxB = GetBox(boxPos + int3(0, 0, offset.z));
  int boxB_Start = _BoxStart[boxB];
  int boxB_End = _BoxEnd[boxB + 1];

  doParticleForeach(index, boxB_Start, boxB_End, particle, depenetration);

  int boxC = GetBox(boxPos + int3(0, offset.y, offset.z));
  int boxC_Start = _BoxStart[boxC];
  int boxC_End = _BoxEnd[boxC + 1];

  doParticleForeach(index, boxC_Start, boxC_End, particle, depenetration);

  int boxD = GetBox(boxPos + int3(0, 0, 0));
  uint boxD_Start = _BoxStart[boxD];
  uint boxD_End = index;

  doParticleForeach(index, boxD_Start, boxD_End, particle, depenetration);

  uint boxE_Start = index + 1;
  uint boxE_End = _BoxEnd[boxD + 1];

  doParticleForeach(index, boxE_Start, boxE_End, particle, depenetration);
  
  if (depenetration.w > 0) {
    particle.position += depenetration.xyz / depenetration.w;
  }
}

[numthreads(64, 1, 1)]
void ResolveCollisions(uint3 id : SV_DispatchThreadID) {
  uint index = id.x;

  //Grab the particle from the front buffer
  Particle particle = _ParticleFront[index];

  //resolveParticleCollisions3x3(index, particle);
  resolveParticleCollisions2x2(index, particle);

  for (int i = 0; i < _CapsuleCount; i++) {
    Capsule capsule = _Capsules[i];

    float3 ba = capsule.b - capsule.a;
    float3 anchor = lerp(capsule.a, capsule.b, saturate(dot(particle.position - capsule.a, ba) / dot(ba, ba)));
    float3 delta = particle.position - anchor;

    if (length(delta) > 0) {
      particle.position = lerp(particle.position, anchor + normalize(delta) * max(CAPSULE_RADIUS, length(delta)), 0.09);
    }
  }

  float boxSize = 0.9;

  float clampHeight = 0.3;
  float clampRadius = 0.9;


  //BOX
  float3 clamped = clamp(particle.position, -boxSize, boxSize);

  //CYLINDER
  //float3 clamped = particle.position;
  //clamped.y = clamp(clamped.y, -clampHeight, clampHeight);
  //clamped.xz = normalize(clamped.xz) * min(clampRadius, length(clamped.xz));

  //SPHERE
  //float3 clamped = normalize(particle.position) * min(clampRadius, length(particle.position));

  particle.position += 2 * (clamped - particle.position);

  //particle.velocity *= 0.99;

  //Increment the count of the new box we have landed in
  uint newBox = GetBox(particle.position);
  InterlockedAdd(_Count[newBox], 1);

  float r = noise(float2(newBox, newBox * 23));
  float g = noise(float2(newBox * 44, newBox + 99));
  float b = noise(float2(newBox * 3.4, newBox * 9));

  //particle.color = float3(r, g, b);

  float3 disp = particle.position - particle.prevPosition;
  particle.color = lerp(particle.color, abs(70 * disp), 0.05);

  //Store the particle into the back buffer
  _ParticleBack[index] = particle;
}

[numthreads(4, 4, 4)]
void Accumulate_X(uint3 id : SV_DispatchThreadID)
{
  uint start = id.y * BOX_SIDE + id.z * BOX_SIDE * BOX_SIDE;
  uint index = start + id.x;

  uint sum = 0;
  for (uint i = start; i <= index; i++) {
    sum += _Count[i];
  }

  _BoxStart[index] = sum;
}

[numthreads(4, 4, 4)]
void Accumulate_Y(uint3 id : SV_DispatchThreadID)
{
  uint index = id.x + id.y * BOX_SIDE + id.z * BOX_SIDE * BOX_SIDE;
  uint start = (BOX_SIDE - 1) + id.z * BOX_SIDE * BOX_SIDE;

  uint sum = _BoxStart[index];
  for (uint i = start; i < index; i += BOX_SIDE) {
    sum += _BoxStart[i];
  }

  _BoxEnd[index] = sum;
}

[numthreads(4, 4, 4)]
void Accumulate_Z(uint3 id : SV_DispatchThreadID)
{
  uint index = id.x + id.y * BOX_SIDE + id.z * BOX_SIDE * BOX_SIDE;
  uint start = (BOX_SIDE - 1) + ((BOX_SIDE - 1) * BOX_SIDE);

  uint sum = _BoxEnd[index];
  for (uint i = start; i < index; i += (BOX_SIDE * BOX_SIDE)) {
    sum += _BoxEnd[i];
  }

  _BoxStart[index] = sum;
}

[numthreads(64, 1, 1)]
void Copy(uint3 id : SV_DispatchThreadID) {
  uint index = id.x;

  _BoxEnd[index] = _BoxStart[index];
  _Count[index] = 0;
}

[numthreads(64, 1, 1)]
void Sort(uint3 id : SV_DispatchThreadID) {
  uint index = id.x;

  Particle particle = _ParticleBack[index];

  uint box = GetBox(particle.position);

  uint newIndex;
  InterlockedAdd(_BoxStart[box], -1, newIndex);
  newIndex--;

  _ParticleFront[newIndex] = particle;
}
