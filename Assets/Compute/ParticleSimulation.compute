#pragma kernel Simulate_Basic
#include "Assets/Shaders/ParticleData.cginc"

uniform int _MaxParticles;
uniform float _DeltaTime;

RWStructuredBuffer<Particle> _Particles;

//Called once for every particle!
[numthreads(64,1,1)]
void Simulate_Basic (uint3 id_full : SV_DispatchThreadID)
{
  /*
  uint index = id_full.x;

  Particle p = _Particles[index];

  //float3 force = 0.01 * (float3(0,0,0) - p.position);
  //p.velocity += force;

  float4 accumForce = float4(0,0,0,0);

  //Loop through every other particle to compare against this particle
  for(uint i=0; i < _MaxParticles; i++) {
    //Dont compare against ourself!
    if(i == index) continue;

    Particle other = _Particles[i];
    float3 toOther = other.position - p.position;
    float distanceSqrd = dot(toOther, toOther);
    
    if(distanceSqrd < MAX_SOCIAL_RANGE * MAX_SOCIAL_RANGE && distanceSqrd > 0) {
      float distance = sqrt(distanceSqrd);

      //This is for long range interaction
      if(distance < MAX_SOCIAL_RANGE) {
        accumForce += float4(MAX_SOCIAL_FORCE * (toOther / distance), 1);
      }

      //This is for collision
      if(distance < RADIUS * 2) {
        float penetration = 1.0 - distance / (2 * RADIUS);
        p.velocity -= _DeltaTime * MAX_COLLISION_FORCE * (toOther / distance) * penetration;
      }
    }
  }

  //Apply accumulated forces towards (or away) from other particles
  if(accumForce.w > 0) {
    //Divide by w, which is the number of particles we are interacting with
    p.velocity += _DeltaTime * accumForce.xyz / accumForce.w;
  }

  //Integration
  p.velocity *= DAMP_CONSTANT;
  p.position += _DeltaTime * p.velocity;

  _Particles[index] = p;
  */
}
