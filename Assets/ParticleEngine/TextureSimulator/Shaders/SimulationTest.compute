#pragma kernel UpdatePosition STRIDE=1024 GROUP=1024

#pragma kernel UpdateVelocity_1024 STRIDE=1024 GROUP=1024
#pragma kernel UpdateVelocity_512  STRIDE=512  GROUP=512
#pragma kernel UpdateVelocity_256  STRIDE=256  GROUP=256
#pragma kernel UpdateVelocity_128  STRIDE=128  GROUP=128
#pragma kernel UpdateVelocity_64   STRIDE=64   GROUP=64 
#pragma kernel UpdateVelocity_32   STRIDE=32   GROUP=32 

#pragma kernel UpdateVelocity_1024_1 STRIDE=1024 GROUP=1024
#pragma kernel UpdateVelocity_512_2  STRIDE=512  GROUP=1024
#pragma kernel UpdateVelocity_256_4  STRIDE=256  GROUP=1024
#pragma kernel UpdateVelocity_128_8  STRIDE=128  GROUP=1024
#pragma kernel UpdateVelocity_64_16  STRIDE=64   GROUP=1024
#pragma kernel UpdateVelocity_32_32  STRIDE=32   GROUP=1024 

#define PARTICLE_RADIUS 0.01
#define PARTICLE_DIAMETER (PARTICLE_RADIUS * 2)

#define _SocialRange 0.1
#define _SocialForce 0.003
#define _CollisionForce 0.005

RWStructuredBuffer<float4> _Positions;
RWStructuredBuffer<float4> _Velocities;

groupshared float4 _accumulationSpace[1024];
groupshared float4 _cachedParticles[GROUP];

[numthreads(1024, 1, 1)]
void UpdatePosition(uint3 id : SV_DispatchThreadID)
{
  _Positions[id.x].xyz += _Velocities[id.x].xyz;
}

void UpdateVelocity(uint id, uint stride) {
  uint maxParticles = (4096 / stride) * stride;
  uint offset = id % stride;

  float4 position = _Positions[id];
  float4 velocity = _Velocities[id];
  float4 totalSocialForce = float4(0, 0, 0, -1);

  uint i = 0;
  do {
    _cachedParticles[offset] = _Positions[i + offset];

    for(uint j=0; j<stride; j++, i++){
      float4 otherPosition = _cachedParticles[j];

      half3 toOther = otherPosition.xyz - position.xyz;
      half distance = length(toOther);
      toOther = distance < 0.0001 ? half3(0, 0, 0) : toOther / distance;

      if (distance < PARTICLE_DIAMETER) {
        half penetration = 1 - distance / PARTICLE_DIAMETER;
        velocity.xyz -= toOther * penetration * _CollisionForce;
      }

      if (distance < _SocialRange) {
        totalSocialForce += half4(_SocialForce * toOther, 1);
      }
    }
  } while (i != maxParticles);

  if (totalSocialForce.z > 0.5) {
    velocity.xyz += totalSocialForce.xyz / totalSocialForce.w;
  }

  _Velocities[id] = velocity * 2;
}

//particleIndex
//  the index of the particle we are doing work on 0-4096
//groupIndex
//  the index of this thread 0-1024 
//layerNum
//  the layer this thread is working on 0-numLayers
//numLayers
//  the number of layers it takes to accumulate 1 particle
void UpdateVelocity_Layered(uint particleIndex, uint particlesPerGroup, uint groupIndex, uint layerNum, uint numLayers) {

  float4 position = _Positions[particleIndex];
  float4 velocity = _Velocities[particleIndex];
  float4 totalSocialForce = float4(0, 0, 0, -1);

  //Number of elements in a layer, this is the number of particles 
  //we look at inside the inner loop.
  uint layerSize = 1024 / numLayers;

  //The index of the start of our layer
  uint layerIndex = layerNum * numLayers;

  //Have to loop 4 times on outer loop because we can't fit the entire
  //particle space in groupshared memory.  Can only fit 1024 at a time,
  //so we do the algo in 4 passes
  for (uint j = 0; j < 4; j++) {
    _cachedParticles[groupIndex] = _Positions[groupIndex + j * 1024];
    GroupMemoryBarrierWithGroupSync();

    for (uint i = 0; i < layerSize; i++) {
      float4 otherPosition = _cachedParticles[layerIndex + i];

      half3 toOther = otherPosition.xyz - position.xyz;
      half distance = length(toOther);
      toOther = distance < 0.0001 ? half3(0, 0, 0) : toOther / distance;

      if (distance < PARTICLE_DIAMETER) {
        half penetration = 1 - distance / PARTICLE_DIAMETER;
        velocity.xyz -= toOther * penetration * _CollisionForce;
      }

      if (distance < _SocialRange) {
        totalSocialForce += half4(_SocialForce * toOther, 1);
      }
    }
  }

  if (totalSocialForce.z > 0.5) {
    velocity.xyz += totalSocialForce.xyz / totalSocialForce.w;
  }

  int particleAccumIndex = (particleIndex % particlesPerGroup) * numLayers + layerNum;
  _accumulationSpace[particleAccumIndex] = velocity;
  GroupMemoryBarrierWithGroupSync();

  [unroll]
  for (uint s = numLayers / 2; s > 0; s >>= 1) {
    if (layerNum < s) {
      _accumulationSpace[particleAccumIndex] += _accumulationSpace[particleAccumIndex + s];
    }
    GroupMemoryBarrierWithGroupSync();
  }

  if (layerNum == 0) {
    _Velocities[particleIndex] = _accumulationSpace[particleAccumIndex];
  }
}

//VELOCITY

[numthreads(1024, 1, 1)]
void UpdateVelocity_1024(uint3 id : SV_DispatchThreadID)
{
  UpdateVelocity(id.x, 1024);
}

[numthreads(512, 1, 1)]
void UpdateVelocity_512(uint3 id : SV_DispatchThreadID)
{
  UpdateVelocity(id.x, 512);
}

[numthreads(256, 1, 1)]
void UpdateVelocity_256(uint3 id : SV_DispatchThreadID)
{
  UpdateVelocity(id.x, 256);
}

[numthreads(128, 1, 1)]
void UpdateVelocity_128(uint3 id : SV_DispatchThreadID)
{
  UpdateVelocity(id.x, 128);
}

[numthreads(64, 1, 1)]
void UpdateVelocity_64(uint3 id : SV_DispatchThreadID)
{
  UpdateVelocity(id.x, 64);
}

[numthreads(32, 1, 1)]
void UpdateVelocity_32(uint3 id : SV_DispatchThreadID)
{
  UpdateVelocity(id.x, 32);
}

//VELOCITY LAYERED

[numthreads(1024, 1, 1)]
void UpdateVelocity_1024_1(uint3 id : SV_DispatchThreadID, uint groupId : SV_GroupThreadID)
{
  UpdateVelocity_Layered(id.x, 1024, groupId, id.y, 1);
}

[numthreads(512, 2, 1)]
void UpdateVelocity_512_2(uint3 id : SV_DispatchThreadID, uint groupId : SV_GroupThreadID)
{
  UpdateVelocity_Layered(id.x, 512, groupId, id.y, 2);
}

[numthreads(256, 4, 1)]
void UpdateVelocity_256_4(uint3 id : SV_DispatchThreadID, uint groupId : SV_GroupThreadID)
{
  UpdateVelocity_Layered(id.x, 256, groupId, id.y, 4);
}

[numthreads(128, 8, 1)]
void UpdateVelocity_128_8(uint3 id : SV_DispatchThreadID, uint groupId : SV_GroupThreadID)
{
  UpdateVelocity_Layered(id.x, 128, groupId, id.y, 8);
}

[numthreads(64, 16, 1)]
void UpdateVelocity_64_16(uint3 id : SV_DispatchThreadID, uint groupId : SV_GroupThreadID)
{
  UpdateVelocity_Layered(id.x, 64, groupId, id.y, 16);
}

[numthreads(32, 32, 1)]
void UpdateVelocity_32_32(uint3 id : SV_DispatchThreadID, uint groupId : SV_GroupThreadID)
{
  UpdateVelocity_Layered(id.x, 32, groupId, id.y, 32);
}