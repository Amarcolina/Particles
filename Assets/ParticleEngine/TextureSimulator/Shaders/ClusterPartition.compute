#pragma kernel CalculateClusterAssignments
#pragma kernel IntegrateCounts
#pragma kernel SortParticlesIntoClusters
#pragma kernel UpdateClusterCenters
#pragma kernel OrganizeClustersX
#pragma kernel OrganizeClustersY
#pragma kernel CheckParticlesForNaN

#define TOTAL_CLUSTERS 64
#define MAX_SOCIAL_RANGE 0.5

struct Cluster {
  float3 center;
  float radius;
  uint count;
  uint4 rect;
};

Texture2D<float4> _Particles;
RWTexture2D<float4> _ClusteredParticles;

RWStructuredBuffer<Cluster> _Clusters;
RWStructuredBuffer<uint> _ClusterAssignments;
RWStructuredBuffer<uint> _Debug;

float lengthSqrd(float3 v) {
  return dot(v, v);
}

[numthreads(8, 8, 1)]
void CalculateClusterAssignments (uint3 id : SV_DispatchThreadID) {
  float4 particle = _Particles[id.xy];

  uint closestClusterIndex = 0;
  float closestDistance = lengthSqrd(_Clusters[0].center - particle.xyz);

  for (uint i = 1; i < TOTAL_CLUSTERS; i++) {
    float distance = lengthSqrd(_Clusters[i].center - particle.xyz);
    if (distance < closestDistance) {
      closestClusterIndex = i;
      closestDistance = distance;
    }
  }

  _ClusterAssignments[id.x * 64 + id.y] = closestClusterIndex;

  InterlockedAdd(_Clusters[closestClusterIndex].count, 1);
}

[numthreads(1, 1, 1)]
void IntegrateCounts(uint3 id : SV_DispatchThreadID) {
  uint rowHeight = 0;
  uint x = 0;
  uint y = 0;

  for (uint i = 0; i < TOTAL_CLUSTERS; i++) {
    uint side = (uint)(1 + sqrt(_Clusters[i].count));
    if (x + side >= 128) {
      x = 0;
      y += rowHeight;
      rowHeight = 0;
    }

    _Clusters[i].rect = uint4(x, y, side, 0);
    x += side;

    rowHeight = max(side, rowHeight);
  }
}

[numthreads(8, 8, 1)]
void SortParticlesIntoClusters(uint3 id : SV_DispatchThreadID) {
  float4 particle = _Particles[id.xy];
  uint clusterAssignment = _ClusterAssignments[id.x * 64 + id.y];

  uint newIndex;
  InterlockedAdd(_Clusters[clusterAssignment].rect.w, 1, newIndex);

  uint4 rect = _Clusters[clusterAssignment].rect;
  uint x = newIndex % rect.z + rect.x;
  newIndex = newIndex & 0x0FFFFFFF;
  uint y = newIndex / rect.z + rect.y;

  _ClusteredParticles[uint2(x, y)] = particle;
}

[numthreads(1, 1, 1)]
void UpdateClusterCenters(uint3 id : SV_DispatchThreadID) {
  GroupMemoryBarrier();

  Cluster cluster = _Clusters[id.x];

  cluster.center = float3(0, 0, 0);
  cluster.radius = 0;

  uint i;
  uint2 dd;
  uint count = cluster.count;

  dd = uint2(0, 0);
  for (i = 0; i < count; i++) {
    cluster.center += _ClusteredParticles[cluster.rect.xy + dd].xyz;
    dd.x++;
    if (dd.x == cluster.rect.z) {
      dd.x = 0;
      dd.y++;
    }
  }

  if (count == 0) {
    cluster.center = float3((id.x - 32.0) * 0.05, 0, 0);
  } else {
    cluster.center /= count;
  }

  dd = uint2(0, 0);
  for (i = 0; i < count; i++) {
    cluster.radius = max(cluster.radius, length(_ClusteredParticles[cluster.rect.xy + dd].xyz - cluster.center));
    dd.x++;
    if (dd.x == cluster.rect.z) {
      dd.x = 0;
      dd.y++;
    }
  }

  cluster.count = 0;
  _Clusters[id.x] = cluster;
}

[numthreads(1, 1, 1)]
void OrganizeClustersX(uint3 id : SV_DispatchThreadID) {
  for (uint i = 1; i < TOTAL_CLUSTERS; i++) {
    Cluster a = _Clusters[i - 1];
    Cluster b = _Clusters[i - 0];

    uint axy = a.rect.x + a.rect.y * 128;
    uint bxy = b.rect.x + b.rect.y * 128;
    if ((a.center.x > b.center.x) != (axy > bxy)) {
      _Clusters[i - 1] = b;
      _Clusters[i - 0] = a;
    } else {
      _Clusters[i - 1] = a;
      _Clusters[i - 0] = b;
    }
  }
}

[numthreads(1, 1, 1)]
void OrganizeClustersY(uint3 id : SV_DispatchThreadID) {
  for (uint i = 5; i < TOTAL_CLUSTERS; i++) {
    Cluster a = _Clusters[i - 5];
    Cluster b = _Clusters[i - 0];

    if ((a.center.y > b.center.y) != (a.rect.y > b.rect.y)) {
      _Clusters[i - 5] = b;
      _Clusters[i - 0] = a;
    }
    else {
      _Clusters[i - 5] = a;
      _Clusters[i - 0] = b;
    }
  }
}

[numthreads(64, 1, 1)]
void CheckParticlesForNaN(uint3 id : SV_DispatchThreadID) {
  float4 data = _Particles[uint2(id.x, 0)];
  uint toOr = (isfinite(data.x) && isfinite(data.y) && isfinite(data.z)) ? 0 : 1;
  InterlockedMax(_Debug[0], toOr);
}
